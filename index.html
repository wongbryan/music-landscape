<!DOCTYPE html>
<html lang="en">
    <head>
        
        <style>
        
            #world {
                position: absolute;
                width: 100%;
                height: 100%;
                overflow: hidden;
                background-color: #ffffff;
            }
            
        </style>
             
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/three.js/87/three.min.js"></script>
        
        <script>
            
            var Colors = {
                pink: 0xf4ade4,
                pinkPurple: 0xe866ff,
                purple: 0xb266ff,
                purpleBlue: 0x7c66ff,
                blue: 0x66bbff, 
                darkblue: 0x3300cc
            };
            
        </script>
                
                
    </head>
    
    
    
    
    <body>
        <div id="world"></div>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/three.js/87/three.min.js"></script>
        <script>
        
            window.addEventListener('load', init, false);
            
        
            function init() {
                //  set up the scene, camera, and renderer
                createScene();
                
                //  add the lights
                createLights();
                
                //  add the objects
                createMorph();
                createTest();
                //createSea();
                
                //  start a loop that will update the objects' positions
                //  and render the scene on each frame
                loop();
            }
            
            var scene,
                camera, fieldOfView, aspectRatio, nearPlane, farPlane, HEIGHT, WIDTH, renderer, container;
        
            
            function createScene() {
                
                HEIGHT = window.innerHeight;
                WIDTH = window.innerWidth;
                
                // Create the scene 
                scene = new THREE.Scene();
                
                // Add a fog effect to the scene
                //scene.fog = new THREE.Fog(0xf7d9aa, 100, 1000);
                
                // Create the camera
                aspectRatio = WIDTH / HEIGHT;
                fieldOfView = 90;
                nearPlane = 1;
                farPlane = 1000;
                camera = new THREE.PerspectiveCamera(fieldOfView, aspectRatio, nearPlane, farPlane);
                
                // Setup the position of the camera
                camera.position.x = 0;
                camera.position.z = 20;
                camera.position.y = 30;
                
                camera.lookAt( new THREE.Vector3( 0, 0, 0 ) );
                 
                // Create the renderer
                renderer = new THREE.WebGLRenderer({alpha: true, antialias: true});
                
                // Define the size of the renderer to fill entire screen
                renderer.setSize(WIDTH, HEIGHT);
                
                // Enable shadow rendering
                renderer.shadowMap.enabled = true;
                
                // Add the DOM element of the renderer to the container we created in the HTML
                container = document.getElementById('world');
                container.appendChild(renderer.domElement);
                
                // Listen to the screen: if the user resizes it we have to update the camera and the renderer size
                window.addEventListener('resize', handleWindowResize, false);

            }
            
            function handleWindowResize() {
                // update height and width of the renderer and the camera
                HEIGHT = window.innerHeight;
                WIDTH = window.innerWidth;
                renderer.setSize(WIDTH, HEIGHT);
                camera.aspect = WIDTH / HEIGHT;
                camera.updateProjectionMatrix();
            }
            
            var hemisphereLight, shadowLight;
            
            function createLights() {
                // A hemisphere light is a gradient-colored light;
                // first param is sky color, second is ground color,
                // third param is intensity of light
                hemisphereLight = new THREE.HemisphereLight(0xffe6c9, 0x474747, .2);
                
                hemisphereLight.position.set( 25, 67, 10 );
                
                // A directional light shines from a specific direction.
                // It acts like the sun, that means that all the rays produced are parallel.
                shadowLight = new THREE.DirectionalLight(0xfff9ed, .45);
                
                // Set the direction of the light
                shadowLight.position.set(-240, 200, -45);
                
                // Allow shadow casting
                shadowLight.castShadow = true;
                
                // Define the visible area of the projected shadow
                shadowLight.shadow.camera.left = -100;
                shadowLight.shadow.camera.right = 100;
                shadowLight.shadow.camera.top = 100;
                shadowLight.shadow.camera.bottom = -100;
                shadowLight.shadow.camera.near = 1;
                shadowLight.shadow.camera.far = 1000;
                
                // define the resolution of the shadow; the higher the better,
                // but also the more expensive and less performant
                shadowLight.shadow.mapSize.width = 2048;
                shadowLight.shadow.mapSize.height = 2048;
                
//                var spotLight = new THREE.SpotLight( 0xffffff );
//                spotLight.position.set( -800, 120, -100);
//
//                spotLight.castShadow = true;
//
//                spotLight.shadow.mapSize.width = 10000;
//                spotLight.shadow.mapSize.height = 10000;
//
//                spotLight.shadow.camera.near = 500;
//                spotLight.shadow.camera.far = 4000;
//                spotLight.shadow.camera.fov = 30;

                //scene.add( spotLight );
                
                // to activate the lights, just add them to the scene
                scene.add(hemisphereLight);
                scene.add(shadowLight);
                
                // an ambient light modifies the global color of the scene and makes shadows softer
                ambientLight = new THREE.AmbientLight(0xaaaaaa, .97);
                ambientLight.position.set( 20,-55,-20 );
                scene.add(ambientLight);
                
            }
            
            
            Morph = function() {
                
                this.mesh = new THREE.Object3D();
                
                var morphGeom = new THREE.BoxGeometry(5000, 100, 5000, 1, 1, 1);
//                var morphMat = new THREE.MeshStandardMaterial({
//                    color: Colors.pink, 
//                    emissive: Colors.pinkPurple, 
//                    roughness: 0,
//                    metalness: .5,
//                })
                
                var morphMat = new THREE.MeshPhongMaterial({
                    color: Colors.pink, 
                    shading: THREE.FlatShading,
                    shininess: 20
//                    roughness: 1,
//                    metalness: 0.43
                });
                
                var morph = new THREE.Mesh(morphGeom, morphMat);
                
                morph.castShadow = true;
                morph.receiveShadow = true;
                
                this.mesh.add(morph);
                
            }
            
            Test = function() {
                this.mesh = new THREE.Object3D();
                
                var testGeom = new THREE.SphereGeometry(5,50,50);
                
                var testMat = new THREE.MeshPhongMaterial({
                    color: Colors.darkblue,
                    shading: THREE.FlatShading,
                });
                
                var test = new THREE.Mesh(testGeom, testMat);
                test.castShadow = true;
                test.receiveShadow = true;
                
                this.mesh.add(test);
            }
            
            var test;
            
            function createTest() {
                
                test = new Test();
                test.mesh.position.z = 0;
                test.mesh.position.y = 0;
                scene.add(test.mesh);
                
                renderer.render(scene, camera);
            }
            
            var morph;
            
            function createMorph() {
                
                morph = new Morph();
                morph.mesh.position.y = -55;
                scene.add(morph.mesh);
                
                renderer.render(scene, camera);
               
            }
            
            // A Simple Cylinder for a Sea
            // First, let's define a sea object :
            Sea = function () {
                
                this.mesh = new THREE.Object3D();
                
                // create the geometry of the cylinder;
                // parameters: radius top, radius bottom, height, # segments on the radius, # segments vertically
                var geom = new THREE.CylinderGeometry(150, 150, 100, 60, 20);
                
                // rotate the geometry on the x-axis
                geom.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI/2));
                
                // IMPORTANT: by merging vertices, we ensure the continuity of the waves
                geom.mergeVertices();
                
                // get the vertices
                var l = geom.vertices.length;
                
                // create an array to store new data associated to each vertex
                this.waves = [];
                
                for (var i = 0; i < l; i++) {
                    // get each vertex
                    var v = geom.vertices[i];
                    
                    // store some data associated to it
                    this.waves.push({
                        y:v.y,
                        x:v.x,
                        z:v.z,
                        // a random angle
                        ang:Math.random()*Math.PI,
                        // a random distance
                        amp: 5+Math.random(),
                        // a random speed between 0.016 and 0.048 radians / frame
                        speed: Math.random() * 0.01
                    });
                }
                
                // create the material
                var mat = new THREE.MeshPhongMaterial ({
                    color: new THREE.Color(0x3300cc),
                    shading: THREE.FlatShading
                });
                
                
                // To create an object in three.js, we have to create a Mesh
                // which is a combination of a geometry and some material
                this.mesh = new THREE.Mesh(geom, mat);
                
                // Allow the sea to receive shadows
                this.mesh.receiveShadow = true;  
                this.mesh.castShadow = true;
            }
//            
//            // now we create the function that will be called in each frame to update the positions of the vertices to simulate the waves
            Sea.prototype.moveWaves = function() {
                // get the vertices
                var verts = this.mesh.geometry.vertices;
                var l = verts.length;
                
                for (var i = 0; i < l; i++) {
                    var v = verts[i];
                    
                    // get the data associated to it
                    var vprops = this.waves[i];
                    
                    // update the position of the vertex
                    v.x = vprops.x - Math.cos(vprops.ang) + ( vprops.amp );
                    v.y = vprops.y - Math.sin(vprops.ang) + ( vprops.amp ); // ang: random angle, amp: random distance
                    
                    // increment the angle for the next frame
                    vprops.ang -= vprops.speed;
                }
                
                // Tell the renderer that the geometry of the sea has changed. In fact, in order to maintain the best level of performance, three.js caches the geometries and ignores any changes unless we add this line:
                this.mesh.geometry.verticesNeedUpdate = true;
                
//                sea.mesh.rotation.z += 0.005;
            }
            
            
            // Instantiate the sea and add it to the scene:
            
            var sea;
            
            function createSea() {
                sea = new Sea();

                
                // push it a little bit at the bottom of the scene
                sea.mesh.position.y = -10;
                sea.mesh.position.x = 0;
                sea.mesh.position.z = 0;
                
                sea.mesh.scale.set(.2,.2,.2);
            
                
                
                // add the mesh of the sea to the scene
                scene.add(sea.mesh);

                
            }
            

            
            // Animation
            // create infinite loop for rotation of objects
            function loop() {
                
                // Rotate the sea, and the sky
//                morph.mesh.rotation.z += .02;
//                morph.mesh.rotation.x += .02;
//                sea.mesh.rotation.z += .0001;
            
                // render the scene
                renderer.render(scene, camera);
                
                // call the loop function again
                requestAnimationFrame(loop);
                
                sea.moveWaves();
                
//                sea.mesh.position.z -= 0.05;
//                sea.mesh.position.x -= Math.sin(Math.PI);
        
            }
            
            
            // Follow the Mouse: Adding Interaction
            // Make airplane follow the mouse movements
            // Once the document is loaded, we need to add a listener to the document to check if the mouse is moving
            // For that, we'll modify the init function as follows:
//            function init(event) {
//                createScene();
//                createLights();
//                createSea();
//                
//                // add the listener
//                // target.addEventListener(type, listener, options)
//                // type = a string representing the event type to listen for
//                // listener = the object receiving the notification when the event occurs
//                document.addEventListener('mousemove', handleMouseMove, false);
//                
//                loop();
//            }
            
            
            
        
        </script>

    
    
    
    
    </body>
    
    
    
</html>